import { Component, HostListener, Inject, InjectionToken, ViewChild, ViewEncapsulation, } from "@angular/core";
import { MdlDialogReference } from "@angular-mdl/core";
import * as momentNs from "moment";
import * as i0 from "@angular/core";
import * as i1 from "@angular-mdl/core";
import * as i2 from "@angular/common";
// see https://github.com/ng-packagr/ng-packagr/issues/217
const moment = momentNs;
export const CURRENT_DATE = new InjectionToken("current-date");
export const DATEPICKER_CONFIG = new InjectionToken("datepicker-options");
export class DatePickerDialogComponent {
    constructor(dialog, initialDate, options) {
        this.dialog = dialog;
        this.initialDate = initialDate;
        this.options = options;
        this.prevEnabled = true;
        this.nextEnabled = true;
        this.monthGridDays = [];
        this.mDate = moment(initialDate || new Date());
        this.pmCurrentMonth = moment(initialDate || new Date());
        this.mCurrentMonth = this.mDate.clone();
        const startOfWeek = moment().startOf("week");
        const endOfWeek = moment().endOf("week");
        this.monthGridWeekDays = [];
        let day = startOfWeek;
        while (day <= endOfWeek) {
            this.monthGridWeekDays.push(moment.weekdaysMin(day.day()));
            day = day.clone().add(1, "d");
        }
        this.okLabel = options.okLabel || "Ok";
        this.cancelLabel = options.cancelLabel || "Cancel";
        dialog.onVisible().subscribe(() => {
            this.okButton?.elementRef.nativeElement.focus();
        });
    }
    get mCurrentMonth() {
        return this.pmCurrentMonth;
    }
    set mCurrentMonth(m) {
        this.pmCurrentMonth = m;
        this.calculateMonthGrid();
    }
    onEsc() {
        this.dialog.hide(this.initialDate);
    }
    onOk() {
        this.dialog.hide(this.mDate.toDate());
    }
    onCancel() {
        this.dialog.hide(this.initialDate);
    }
    prevMonth() {
        this.mCurrentMonth = this.mCurrentMonth.subtract(1, "months");
    }
    nextMonth() {
        this.mCurrentMonth = this.mCurrentMonth.add(1, "months");
    }
    isActualDate(day) {
        return this.mDate.isSame(day, "day");
    }
    setCurrentDay(day) {
        this.mDate = day;
    }
    calculateMonthGrid() {
        const startDateOfMonth = this.mCurrentMonth
            .clone()
            .startOf("month")
            .clone();
        const startWeek = startDateOfMonth.week();
        const endWeek = this.mCurrentMonth.clone().endOf("month").week();
        // caveat year switch
        // 52 - 5
        // 48 - 1
        // console.log(startWeek, endWeek);
        this.monthGridDays = [];
        let week = startWeek;
        this.monthGridDays.push(this.createMonthRow(startDateOfMonth, week));
        do {
            const firstDayInWeek = startDateOfMonth.add(1, "week");
            week = firstDayInWeek.week();
            this.monthGridDays.push(this.createMonthRow(firstDayInWeek.clone(), week));
        } while (week !== endWeek);
    }
    createMonthRow(mDate, week) {
        const startWeek = mDate.week(week).startOf("week");
        return {
            week,
            days: Array(7)
                .fill(0)
                .map((n, i) => {
                const mDay = startWeek.clone().add(i, "day");
                return {
                    day: mDay,
                    isCurrentMonth: this.isCurrentMonth(mDay),
                };
            }),
        };
    }
    isCurrentMonth(day) {
        return this.mCurrentMonth.isSame(day, "month");
    }
}
DatePickerDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: DatePickerDialogComponent, deps: [{ token: i1.MdlDialogReference }, { token: CURRENT_DATE }, { token: DATEPICKER_CONFIG }], target: i0.ɵɵFactoryTarget.Component });
DatePickerDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: DatePickerDialogComponent, selector: "datepicker", host: { listeners: { "keydown.esc": "onEsc()" } }, viewQueries: [{ propertyName: "okButton", first: true, predicate: ["okButton"], descendants: true }], ngImport: i0, template: "<div class=\"mdl-datepicker-header\">\n  <div class=\"mdl-datepicker-header-year\">{{mDate.format('YYYY')}}</div>\n  <h3 class=\"mdl-datepicker-header-day-month\">{{mDate.format('ddd, MMM DD')}}</h3>\n</div>\n\n<div class=\"mdl-dialog__content\">\n  <div class=\"mdl-datepicker-month-navigation-buttons\">\n    <button (click)=\"prevMonth()\" [disabled]=\"!prevEnabled\" class=\"mdl-datepicker-prev-month\" mdl-button\n            mdl-button-type=\"icon\">\n      <mdl-icon>keyboard_arrow_left</mdl-icon>\n    </button>\n    <button (click)=\"nextMonth()\" [disabled]=\"!nextEnabled\" class=\"mdl-datepicker-next-month\" mdl-button\n            mdl-button-type=\"icon\">\n      <mdl-icon>keyboard_arrow_right</mdl-icon>\n    </button>\n  </div>\n  <div class=\"mdl-datepicker-month\">\n    <div class=\"mdl-datepicker-month-title\">{{mCurrentMonth.format('MMMM YYYY')}}</div>\n    <div class=\"mdl-datepicker-weekdays\">\n      <div *ngFor=\"let wd of monthGridWeekDays\" class=\"mdl-datepicker-weekday\">{{wd}}</div>\n    </div>\n    <div class=\"mdl-datepicker-monthgrid\">\n\n      <div *ngFor=\"let week of monthGridDays\" class=\"mdl-datepicker-weekdays\">\n        <div *ngFor=\"let dayInfo of week.days\"\n             class=\"mdl-datepicker-weekday\">\n          <button\n            (click)=\"setCurrentDay(dayInfo.day)\"\n            [disabled]=\"!dayInfo.isCurrentMonth\"\n            [ngClass]=\"{'actual': isActualDate(dayInfo.day)}\"\n            class=\"day\"\n            mdl-button\n            mdl-ripple\n          >{{dayInfo.day.date()}}</button>\n        </div>\n      </div>\n\n    </div>\n  </div>\n\n</div>\n<div class=\"mdl-dialog__actions\">\n  <button #okButton\n          (click)=\"onOk()\" class=\"close mdl-datepicker-ok-button\"\n          mdl-button\n          mdl-colored=\"primary\"\n          type=\"button\">{{okLabel}}</button>\n  <button\n    (click)=\"onCancel()\" class=\"mdl-datepicker-cancel-button\"\n    mdl-button\n    mdl-colored=\"primary\"\n    type=\"button\">{{cancelLabel}}</button>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: i1.MdlButtonComponent, selector: "mdl-button, button[mdl-button], a[mdl-button]", inputs: ["mdl-button-type", "mdl-colored", "disabled"], exportAs: ["mdlButton"] }, { kind: "component", type: i1.MdlIconComponent, selector: "mdl-icon" }, { kind: "directive", type: i1.MdlButtonRippleDirective, selector: "mdl-button[mdl-ripple], button[mdl-ripple]", inputs: ["mdl-ripple"] }], encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: DatePickerDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: "datepicker", encapsulation: ViewEncapsulation.None, template: "<div class=\"mdl-datepicker-header\">\n  <div class=\"mdl-datepicker-header-year\">{{mDate.format('YYYY')}}</div>\n  <h3 class=\"mdl-datepicker-header-day-month\">{{mDate.format('ddd, MMM DD')}}</h3>\n</div>\n\n<div class=\"mdl-dialog__content\">\n  <div class=\"mdl-datepicker-month-navigation-buttons\">\n    <button (click)=\"prevMonth()\" [disabled]=\"!prevEnabled\" class=\"mdl-datepicker-prev-month\" mdl-button\n            mdl-button-type=\"icon\">\n      <mdl-icon>keyboard_arrow_left</mdl-icon>\n    </button>\n    <button (click)=\"nextMonth()\" [disabled]=\"!nextEnabled\" class=\"mdl-datepicker-next-month\" mdl-button\n            mdl-button-type=\"icon\">\n      <mdl-icon>keyboard_arrow_right</mdl-icon>\n    </button>\n  </div>\n  <div class=\"mdl-datepicker-month\">\n    <div class=\"mdl-datepicker-month-title\">{{mCurrentMonth.format('MMMM YYYY')}}</div>\n    <div class=\"mdl-datepicker-weekdays\">\n      <div *ngFor=\"let wd of monthGridWeekDays\" class=\"mdl-datepicker-weekday\">{{wd}}</div>\n    </div>\n    <div class=\"mdl-datepicker-monthgrid\">\n\n      <div *ngFor=\"let week of monthGridDays\" class=\"mdl-datepicker-weekdays\">\n        <div *ngFor=\"let dayInfo of week.days\"\n             class=\"mdl-datepicker-weekday\">\n          <button\n            (click)=\"setCurrentDay(dayInfo.day)\"\n            [disabled]=\"!dayInfo.isCurrentMonth\"\n            [ngClass]=\"{'actual': isActualDate(dayInfo.day)}\"\n            class=\"day\"\n            mdl-button\n            mdl-ripple\n          >{{dayInfo.day.date()}}</button>\n        </div>\n      </div>\n\n    </div>\n  </div>\n\n</div>\n<div class=\"mdl-dialog__actions\">\n  <button #okButton\n          (click)=\"onOk()\" class=\"close mdl-datepicker-ok-button\"\n          mdl-button\n          mdl-colored=\"primary\"\n          type=\"button\">{{okLabel}}</button>\n  <button\n    (click)=\"onCancel()\" class=\"mdl-datepicker-cancel-button\"\n    mdl-button\n    mdl-colored=\"primary\"\n    type=\"button\">{{cancelLabel}}</button>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.MdlDialogReference }, { type: Date, decorators: [{
                    type: Inject,
                    args: [CURRENT_DATE]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DATEPICKER_CONFIG]
                }] }]; }, propDecorators: { okButton: [{
                type: ViewChild,
                args: ["okButton"]
            }], onEsc: [{
                type: HostListener,
                args: ["keydown.esc"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9kYXRlcGlja2VyL3NyYy9saWIvZGF0ZXBpY2tlci5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9kYXRlcGlja2VyL3NyYy9saWIvZGF0ZXBpY2tlci5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFlBQVksRUFDWixNQUFNLEVBQ04sY0FBYyxFQUNkLFNBQVMsRUFDVCxpQkFBaUIsR0FDbEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFzQixrQkFBa0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzNFLE9BQU8sS0FBSyxRQUFRLE1BQU0sUUFBUSxDQUFDOzs7O0FBR25DLDBEQUEwRDtBQUMxRCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFFeEIsTUFBTSxDQUFDLE1BQU0sWUFBWSxHQUFHLElBQUksY0FBYyxDQUFPLGNBQWMsQ0FBQyxDQUFDO0FBQ3JFLE1BQU0sQ0FBQyxNQUFNLGlCQUFpQixHQUFHLElBQUksY0FBYyxDQUNqRCxvQkFBb0IsQ0FDckIsQ0FBQztBQWtCRixNQUFNLE9BQU8seUJBQXlCO0lBY3BDLFlBQ1UsTUFBMEIsRUFDSixXQUFpQixFQUNaLE9BQTBCO1FBRnJELFdBQU0sR0FBTixNQUFNLENBQW9CO1FBQ0osZ0JBQVcsR0FBWCxXQUFXLENBQU07UUFDWixZQUFPLEdBQVAsT0FBTyxDQUFtQjtRQVQvRCxnQkFBVyxHQUFHLElBQUksQ0FBQztRQUNuQixnQkFBVyxHQUFHLElBQUksQ0FBQztRQUVuQixrQkFBYSxHQUFhLEVBQUUsQ0FBQztRQVEzQixJQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxXQUFXLElBQUksSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxjQUFj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TCxDQUFDO0lBQ0osQ0FBQztJQUVPLGNBQWMsQ0FBQyxHQUFvQjtRQUN6QyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNqRCxDQUFDOztzSEE1SFUseUJBQXlCLG9EQWdCMUIsWUFBWSxhQUNaLGlCQUFpQjswR0FqQmhCLHlCQUF5QiwyTUNwQ3RDLDYvREFxREE7MkZEakJhLHlCQUF5QjtrQkFOckMsU0FBUzsrQkFFRSxZQUFZLGlCQUVQLGlCQUFpQixDQUFDLElBQUk7OzBCQWtCbEMsTUFBTTsyQkFBQyxZQUFZOzswQkFDbkIsTUFBTTsyQkFBQyxpQkFBaUI7NENBZjNCLFFBQVE7c0JBRFAsU0FBUzt1QkFBQyxVQUFVO2dCQWtEZCxLQUFLO3NCQURYLFlBQVk7dUJBQUMsYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgSG9zdExpc3RlbmVyLFxuICBJbmplY3QsXG4gIEluamVjdGlvblRva2VuLFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgTWRsQnV0dG9uQ29tcG9uZW50LCBNZGxEaWFsb2dSZWZlcmVuY2UgfSBmcm9tIFwiQGFuZ3VsYXItbWRsL2NvcmVcIjtcbmltcG9ydCAqIGFzIG1vbWVudE5zIGZyb20gXCJtb21lbnRcIjtcbmltcG9ydCB7IERhdGVQaWNrZXJPcHRpb25zIH0gZnJvbSBcIi4vZGF0ZS1waWNrZXItb3B0aW9uXCI7XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbmctcGFja2Fnci9uZy1wYWNrYWdyL2lzc3Vlcy8yMTdcbmNvbnN0IG1vbWVudCA9IG1vbWVudE5zO1xuXG5leHBvcnQgY29uc3QgQ1VSUkVOVF9EQVRFID0gbmV3IEluamVjdGlvblRva2VuPERhdGU+KFwiY3VycmVudC1kYXRlXCIpO1xuZXhwb3J0IGNvbnN0IERBVEVQSUNLRVJfQ09ORklHID0gbmV3IEluamVjdGlvblRva2VuPERhdGVQaWNrZXJPcHRpb25zPihcbiAgXCJkYXRlcGlja2VyLW9wdGlvbnNcIlxuKTtcblxuaW50ZXJmYWNlIERwRGF5cyB7XG4gIGlzQ3VycmVudE1vbnRoOiBib29sZWFuO1xuICBkYXk6IG1vbWVudE5zLk1vbWVudDtcbn1cblxuaW50ZXJmYWNlIERwV2VlayB7XG4gIGRheXM6IERwRGF5c1tdO1xuICB3ZWVrOiBudW1iZXI7XG59XG5cbkBDb21wb25lbnQoe1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgc2VsZWN0b3I6IFwiZGF0ZXBpY2tlclwiLFxuICB0ZW1wbGF0ZVVybDogXCJkYXRlcGlja2VyLmNvbXBvbmVudC5odG1sXCIsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG59KVxuZXhwb3J0IGNsYXNzIERhdGVQaWNrZXJEaWFsb2dDb21wb25lbnQge1xuICBAVmlld0NoaWxkKFwib2tCdXR0b25cIilcbiAgb2tCdXR0b246IE1kbEJ1dHRvbkNvbXBvbmVudCB8IHVuZGVmaW5lZDtcblxuICBva0xhYmVsOiBzdHJpbmc7XG4gIGNhbmNlbExhYmVsOiBzdHJpbmc7XG5cbiAgbURhdGU6IG1vbWVudE5zLk1vbWVudDtcbiAgcHJldkVuYWJsZWQgPSB0cnVlO1xuICBuZXh0RW5hYmxlZCA9IHRydWU7XG4gIG1vbnRoR3JpZFdlZWtEYXlzOiBzdHJpbmdbXTtcbiAgbW9udGhHcmlkRGF5czogRHBXZWVrW10gPSBbXTtcbiAgcG1DdXJyZW50TW9udGg6IG1vbWVudE5zLk1vbWVudDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGRpYWxvZzogTWRsRGlhbG9nUmVmZXJlbmNlLFxuICAgIEBJbmplY3QoQ1VSUkVOVF9EQVRFKSBwcml2YXRlIGluaXRpYWxEYXRlOiBEYXRlLFxuICAgIEBJbmplY3QoREFURVBJQ0tFUl9DT05GSUcpIHByaXZhdGUgb3B0aW9uczogRGF0ZVBpY2tlck9wdGlvbnNcbiAgKSB7XG4gICAgdGhpcy5tRGF0ZSA9IG1vbWVudChpbml0aWFsRGF0ZSB8fCBuZXcgRGF0ZSgpKTtcbiAgICB0aGlzLnBtQ3VycmVudE1vbnRoID0gbW9tZW50KGluaXRpYWxEYXRlIHx8IG5ldyBEYXRlKCkpO1xuICAgIHRoaXMubUN1cnJlbnRNb250aCA9IHRoaXMubURhdGUuY2xvbmUoKTtcblxuICAgIGNvbnN0IHN0YXJ0T2ZXZWVrID0gbW9tZW50KCkuc3RhcnRPZihcIndlZWtcIik7XG4gICAgY29uc3QgZW5kT2ZXZWVrID0gbW9tZW50KCkuZW5kT2YoXCJ3ZWVrXCIpO1xuXG4gICAgdGhpcy5tb250aEdyaWRXZWVrRGF5cyA9IFtdO1xuICAgIGxldCBkYXkgPSBzdGFydE9mV2VlaztcbiAgICB3aGlsZSAoZGF5IDw9IGVuZE9mV2Vlaykge1xuICAgICAgdGhpcy5tb250aEdyaWRXZWVrRGF5cy5wdXNoKG1vbWVudC53ZWVrZGF5c01pbihkYXkuZGF5KCkpKTtcbiAgICAgIGRheSA9IGRheS5jbG9uZSgpLmFkZCgxLCBcImRcIik7XG4gICAgfVxuXG4gICAgdGhpcy5va0xhYmVsID0gb3B0aW9ucy5va0xhYmVsIHx8IFwiT2tcIjtcbiAgICB0aGlzLmNhbmNlbExhYmVsID0gb3B0aW9ucy5jYW5jZWxMYWJlbCB8fCBcIkNhbmNlbFwiO1xuXG4gICAgZGlhbG9nLm9uVmlzaWJsZSgpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLm9rQnV0dG9uPy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBtQ3VycmVudE1vbnRoKCk6IG1vbWVudE5zLk1vbWVudCB7XG4gICAgcmV0dXJuIHRoaXMucG1DdXJyZW50TW9udGg7XG4gIH1cblxuICBzZXQgbUN1cnJlbnRNb250aChtOiBtb21lbnROcy5Nb21lbnQpIHtcbiAgICB0aGlzLnBtQ3VycmVudE1vbnRoID0gbTtcbiAgICB0aGlzLmNhbGN1bGF0ZU1vbnRoR3JpZCgpO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcihcImtleWRvd24uZXNjXCIpXG4gIHB1YmxpYyBvbkVzYygpOiB2b2lkIHtcbiAgICB0aGlzLmRpYWxvZy5oaWRlKHRoaXMuaW5pdGlhbERhdGUpO1xuICB9XG5cbiAgb25PaygpOiB2b2lkIHtcbiAgICB0aGlzLmRpYWxvZy5oaWRlKHRoaXMubURhdGUudG9EYXRlKCkpO1xuICB9XG5cbiAgb25DYW5jZWwoKTogdm9pZCB7XG4gICAgdGhpcy5kaWFsb2cuaGlkZSh0aGlzLmluaXRpYWxEYXRlKTtcbiAgfVxuXG4gIHByZXZNb250aCgpOiB2b2lkIHtcbiAgICB0aGlzLm1DdXJyZW50TW9udGggPSB0aGlzLm1DdXJyZW50TW9udGguc3VidHJhY3QoMSwgXCJtb250aHNcIik7XG4gIH1cblxuICBuZXh0TW9udGgoKTogdm9pZCB7XG4gICAgdGhpcy5tQ3VycmVudE1vbnRoID0gdGhpcy5tQ3VycmVudE1vbnRoLmFkZCgxLCBcIm1vbnRoc1wiKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0FjdHVhbERhdGUoZGF5OiBtb21lbnROcy5Nb21lbnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5tRGF0ZS5pc1NhbWUoZGF5LCBcImRheVwiKTtcbiAgfVxuXG4gIHNldEN1cnJlbnREYXkoZGF5OiBtb21lbnROcy5Nb21lbnQpOiB2b2lkIHtcbiAgICB0aGlzLm1EYXRlID0gZGF5O1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVNb250aEdyaWQoKSB7XG4gICAgY29uc3Qgc3RhcnREYXRlT2ZNb250aCA9IHRoaXMubUN1cnJlbnRNb250aFxuICAgICAgLmNsb25lKClcbiAgICAgIC5zdGFydE9mKFwibW9udGhcIilcbiAgICAgIC5jbG9uZSgpO1xuICAgIGNvbnN0IHN0YXJ0V2VlayA9IHN0YXJ0RGF0ZU9mTW9udGgud2VlaygpO1xuICAgIGNvbnN0IGVuZFdlZWsgPSB0aGlzLm1DdXJyZW50TW9udGguY2xvbmUoKS5lbmRPZihcIm1vbnRoXCIpLndlZWsoKTtcblxuICAgIC8vIGNhdmVhdCB5ZWFyIHN3aXRjaFxuICAgIC8vIDUyIC0gNVxuICAgIC8vIDQ4IC0gMVxuICAgIC8vIGNvbnNvbGUubG9nKHN0YXJ0V2VlaywgZW5kV2Vlayk7XG5cbiAgICB0aGlzLm1vbnRoR3JpZERheXMgPSBbXTtcbiAgICBsZXQgd2VlayA9IHN0YXJ0V2VlaztcblxuICAgIHRoaXMubW9udGhHcmlkRGF5cy5wdXNoKHRoaXMuY3JlYXRlTW9udGhSb3coc3RhcnREYXRlT2ZNb250aCwgd2VlaykpO1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgZmlyc3REYXlJbldlZWsgPSBzdGFydERhdGVPZk1vbnRoLmFkZCgxLCBcIndlZWtcIik7XG4gICAgICB3ZWVrID0gZmlyc3REYXlJbldlZWsud2VlaygpO1xuICAgICAgdGhpcy5tb250aEdyaWREYXlzLnB1c2goXG4gICAgICAgIHRoaXMuY3JlYXRlTW9udGhSb3coZmlyc3REYXlJbldlZWsuY2xvbmUoKSwgd2VlaylcbiAgICAgICk7XG4gICAgfSB3aGlsZSAod2VlayAhPT0gZW5kV2Vlayk7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZU1vbnRoUm93KG1EYXRlOiBtb21lbnROcy5Nb21lbnQsIHdlZWs6IG51bWJlcik6IERwV2VlayB7XG4gICAgY29uc3Qgc3RhcnRXZWVrID0gbURhdGUud2Vlayh3ZWVrKS5zdGFydE9mKFwid2Vla1wiKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2VlayxcbiAgICAgIGRheXM6IEFycmF5KDcpXG4gICAgICAgIC5maWxsKDApXG4gICAgICAgIC5tYXAoKG4sIGkpID0+IHtcbiAgICAgICAgICBjb25zdCBtRGF5ID0gc3RhcnRXZWVrLmNsb25lKCkuYWRkKGksIFwiZGF5XCIpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXk6IG1EYXksXG4gICAgICAgICAgICBpc0N1cnJlbnRNb250aDogdGhpcy5pc0N1cnJlbnRNb250aChtRGF5KSxcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBpc0N1cnJlbnRNb250aChkYXk6IG1vbWVudE5zLk1vbWVudCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm1DdXJyZW50TW9udGguaXNTYW1lKGRheSwgXCJtb250aFwiKTtcbiAgfVxufVxuIiwiPGRpdiBjbGFzcz1cIm1kbC1kYXRlcGlja2VyLWhlYWRlclwiPlxuICA8ZGl2IGNsYXNzPVwibWRsLWRhdGVwaWNrZXItaGVhZGVyLXllYXJcIj57e21EYXRlLmZvcm1hdCgnWVlZWScpfX08L2Rpdj5cbiAgPGgzIGNsYXNzPVwibWRsLWRhdGVwaWNrZXItaGVhZGVyLWRheS1tb250aFwiPnt7bURhdGUuZm9ybWF0KCdkZGQsIE1NTSBERCcpfX08L2gzPlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJtZGwtZGlhbG9nX19jb250ZW50XCI+XG4gIDxkaXYgY2xhc3M9XCJtZGwtZGF0ZXBpY2tlci1tb250aC1uYXZpZ2F0aW9uLWJ1dHRvbnNcIj5cbiAgICA8YnV0dG9uIChjbGljayk9XCJwcmV2TW9udGgoKVwiIFtkaXNhYmxlZF09XCIhcHJldkVuYWJsZWRcIiBjbGFzcz1cIm1kbC1kYXRlcGlja2VyLXByZXYtbW9udGhcIiBtZGwtYnV0dG9uXG4gICAgICAgICAgICBtZGwtYnV0dG9uLXR5cGU9XCJpY29uXCI+XG4gICAgICA8bWRsLWljb24+a2V5Ym9hcmRfYXJyb3dfbGVmdDwvbWRsLWljb24+XG4gICAgPC9idXR0b24+XG4gICAgPGJ1dHRvbiAoY2xpY2spPVwibmV4dE1vbnRoKClcIiBbZGlzYWJsZWRdPVwiIW5leHRFbmFibGVkXCIgY2xhc3M9XCJtZGwtZGF0ZXBpY2tlci1uZXh0LW1vbnRoXCIgbWRsLWJ1dHRvblxuICAgICAgICAgICAgbWRsLWJ1dHRvbi10eXBlPVwiaWNvblwiPlxuICAgICAgPG1kbC1pY29uPmtleWJvYXJkX2Fycm93X3JpZ2h0PC9tZGwtaWNvbj5cbiAgICA8L2J1dHRvbj5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJtZGwtZGF0ZXBpY2tlci1tb250aFwiPlxuICAgIDxkaXYgY2xhc3M9XCJtZGwtZGF0ZXBpY2tlci1tb250aC10aXRsZVwiPnt7bUN1cnJlbnRNb250aC5mb3JtYXQoJ01NTU0gWVlZWScpfX08L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWRsLWRhdGVwaWNrZXItd2Vla2RheXNcIj5cbiAgICAgIDxkaXYgKm5nRm9yPVwibGV0IHdkIG9mIG1vbnRoR3JpZFdlZWtEYXlzXCIgY2xhc3M9XCJtZGwtZGF0ZXBpY2tlci13ZWVrZGF5XCI+e3t3ZH19PC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kbC1kYXRlcGlja2VyLW1vbnRoZ3JpZFwiPlxuXG4gICAgICA8ZGl2ICpuZ0Zvcj1cImxldCB3ZWVrIG9mIG1vbnRoR3JpZERheXNcIiBjbGFzcz1cIm1kbC1kYXRlcGlja2VyLXdlZWtkYXlzXCI+XG4gICAgICAgIDxkaXYgKm5nRm9yPVwibGV0IGRheUluZm8gb2Ygd2Vlay5kYXlzXCJcbiAgICAgICAgICAgICBjbGFzcz1cIm1kbC1kYXRlcGlja2VyLXdlZWtkYXlcIj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAoY2xpY2spPVwic2V0Q3VycmVudERheShkYXlJbmZvLmRheSlcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cIiFkYXlJbmZvLmlzQ3VycmVudE1vbnRoXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsnYWN0dWFsJzogaXNBY3R1YWxEYXRlKGRheUluZm8uZGF5KX1cIlxuICAgICAgICAgICAgY2xhc3M9XCJkYXlcIlxuICAgICAgICAgICAgbWRsLWJ1dHRvblxuICAgICAgICAgICAgbWRsLXJpcHBsZVxuICAgICAgICAgID57e2RheUluZm8uZGF5LmRhdGUoKX19PC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cIm1kbC1kaWFsb2dfX2FjdGlvbnNcIj5cbiAgPGJ1dHRvbiAjb2tCdXR0b25cbiAgICAgICAgICAoY2xpY2spPVwib25PaygpXCIgY2xhc3M9XCJjbG9zZSBtZGwtZGF0ZXBpY2tlci1vay1idXR0b25cIlxuICAgICAgICAgIG1kbC1idXR0b25cbiAgICAgICAgICBtZGwtY29sb3JlZD1cInByaW1hcnlcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIj57e29rTGFiZWx9fTwvYnV0dG9uPlxuICA8YnV0dG9uXG4gICAgKGNsaWNrKT1cIm9uQ2FuY2VsKClcIiBjbGFzcz1cIm1kbC1kYXRlcGlja2VyLWNhbmNlbC1idXR0b25cIlxuICAgIG1kbC1idXR0b25cbiAgICBtZGwtY29sb3JlZD1cInByaW1hcnlcIlxuICAgIHR5cGU9XCJidXR0b25cIj57e2NhbmNlbExhYmVsfX08L2J1dHRvbj5cbjwvZGl2PlxuIl19